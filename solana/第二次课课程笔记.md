
> [!TIP]
> **课程概览**
>
> * **主题**: Solana 链上狙击机器人 (Sniper Bot) 原理与实战 & Solana Token 账户模型深度解析
> * **第一部分 (诺亚 Noah)**: 狙击机器人开发 (架构、Jito、Websocket、安全检查)
> * **第二部分 (潘立雄)**: Solana 账户模型、SPL Token 标准、命令行与代码发币实战

---

## 第一部分：Solana 狙击机器人开发实战 (Sniper Bot)

**主讲人**: 诺亚 (Noah)

### 1. 核心概念与优势

* **发币 (Minting) vs 交易 (Trading)**:
  * **发币**: 印钞过程。项目方定义代币名称、数量（Solana 上 Meme 币通常默认为 10 亿枚）。此时代币存在项目方钱包，不可交易，无价值。
  * **交易**: 需要流动性池 (Liquidity Pool)。项目方将代币与 SOL 也就是组 LP (10亿币 + x SOL) 存入 DEX (如 Raydium)，形成定价（开盘）。
* **为什么要用机器人？**
  * **速度鸿沟**: 人手操作（看推特->点链接->连钱包->签名）最快需 5-15 秒。Solana 理论出块 400ms，几秒钟内价格可能翻倍。
  * **执行优势**: 毫秒级响应、第 0 区块买入、24/7 监控、纯逻辑无情绪执行。
  * **防夹子 (MEV)**: 机器人可使用私有节点或 Jito 捆绑交易，避免被三明治攻击。

### 2. 狙击流派 (Strategies)

1. **流动性狙击 (Liquidity Sniping)**:
    * **原理**: 监听 DEX (Raydium/Orca) 的 `InitializePool` 指令。一旦有人加池子，通过 Logs 捕捉并立即买入。
    * **优点**: 买入时刻最早，价格最低。
    * **风险**: 极高。容易遭遇撤池子 (Rug Pull)、貔貅盘。需配合严格的合约安全检查。
2. **盲狙 (Blind Sniping)**:
    * **场景**: 针对 Pump.fun 等内盘发币平台。监听 `Create` 指令（比上 DEX 流动性更早）。
    * **特点**: 成本低，速度快，但归零率极高 (99.9%)。
    * **优化**: 监控“聪明钱” (Smart Money) 或内幕钱包，跟随胜率高的地址买入。
3. **授权狙击 (Authority Sniping)**:
    * **原理**: 监听项目方放弃 Mint 权限 (`SetAuthority` to None) 或烧毁 LP 代币 (`Burn`) 的动作。
    * **特点**: 确认安全（防 Rug）后再进场。虽然入场价稍高，但安全性大幅提升，适合大资金稳健操作。

### 3. Solana 网络架构与通信机制

* **Mempool (内存池) 差异**:
  * **以太坊**: 公开 Mempool，所有节点可见。
  * **Solana**: 无全局 Mempool。交易直接发给当前的 **Leader** (通过排班表计算 Leader IP)。
  * **Gulf Stream**: Solana 的交易转发协议，但也导致了无休止的垃圾交易轰炸。
* **UDP vs TCP**:
  * Solana 节点间主要通讯使用 **UDP** (发后即忘，不保达)。这解释了为什么交易容易丢包或超时。
  * 狙击机器人通常直接向 Leader 的 TPU (Transaction Processing Unit) 发送 UDP 包以降低延迟。
* **Jito (Solana 的 Flashbots)**:
  * **机制**: 提供 VIP 交易通道 (Bundle)。用户支付小费 (Tip) 给 Validator。
  * **优势**:
        1. **原子性**: Bundle 内的交易要么全成功，要么全失败（防止只买入没卖出）。
        2. **失败不付费**: 只有交易成功上链才扣小费。
        3. **防夹**: 绕过公共网络，直接由特定 Validator 打包，避免被普通 Searcher 夹击。

### 4. 极速开发技术栈

* **拒绝轮询 (Polling)**:
  * `while(true)` 循环查 HTTP 接口是过时的做法。
  * **正确做法**: 使用 **Websocket** 监听。
* **Web3.js 监听代码**:

    ```javascript
    // 像在链上装摄像头，实时推送日志
    connection.onLogs(
        programId,
        (logs, context) => {
            // 解析 logs 发现新池子或新币
            // 立即构造交易 -> 签名 -> 发送
        },
        "processed" // 承诺级别：选择 processed (最低延迟) 而非 confirmed
    );
    ```

* **双跳问题 (Double Hop) 与优化**:
  * **问题**: 监听到 Log 后，Log 中可能没有完整的 Token Mint 地址，需要再调一次 `getTransaction` (HTTP 请求) 获取详情，导致延迟。
  * **优化**:
        1. 使用支持 **Geyser 插件** (gRPC) 的节点，直接推送完整数据。
        2. 使用特定的 RPC 服务商提供的增强 Websocket API。
* **优先费 (Priority Fee)**:
  * 必须设置动态优先费。计算当前区块的中位数手续费，并在此基础上加倍 (e.g., *1.5 或*2)，确保交易被 Leader 优先处理。

### 5. 安全检查 (Security & Honeypots)

在“扣动扳机”前，必须进行安全检查（哪怕牺牲一点速度）：

* **硬编码风险**:
  * **无限印钞**: 检查 Mint Authority 是否已丢弃 (Set to Null)。若未丢弃，项目方可随时增发砸盘。
  * **冻结权限**: 检查 Freeze Authority 是否已丢弃。若存在，项目方可冻结你的账户 (貔貅)。
* **LP 安全**:
  * 检查 LP Token 是否已**烧毁 (Burned)** 或**锁定 (Locked)**。
  * 如果 LP Token 还在项目方手里，他可以随时撤池子跑路。
* **老鼠仓 (Sniper/Insider Wallets)**:
  * 检查前 10 持币地址。如果持仓过于集中 (>30%) 或资金来源单一（分发钱包），极大概率是老鼠仓。
* **貔貅盘 (Honeypot)**:
  * 通过代码逻辑限制卖出（如 `if (is_contract) revert`）。
  * **检测方法**: 使用 **Solana Simulation API** 模拟一笔买入和卖出交易。如果模拟失败，绝对不买。

---

## 第二部分：Solana Token 开发原理与实战

**主讲人**: 潘立雄 (泰迪熊)

### 1. Solana 账户模型 (Account Model)

* **核心理念**: "Everything is an Account" (类似 Linux 的一切皆文件)。
* **账户结构**:
  * `Pubkey`: 地址 (ID)。
  * `Lamports`: 余额 (分)。
  * `Data`: 存储数据 (最大 10MB，需支付租金)。
  * `Owner`: 所有者程序 ID (只有 Owner 能修改 Data)。
  * `Executable`: 是否是程序 (Ref: BPF/SBF)。
* **程序与数据分离**:
  * **以太坊**: 代码和状态 (余额) 都在合约账户里，导致并发困难 (状态竞争)。
  * **Solana**: 程序是**无状态**的 (Stateless) 只读账户。用户数据 (如余额) 存储在独立的数据账户中。这使得 Solana 可以大规模**并发执行**交易。

### 2. Token 标准 (SPL Token)

* **同质化 vs 非同质化**:
  * **Fungible (FT)**: `Decimals > 0` (如 USDC)。
  * **Non-Fungible (NFT)**: `Decimals = 0` 且 `Supply = 1`。
* **账户体系三件套**:
    1. **Mint Account (铸币账户)**:
        * 定义 Token 的元属性：总供应量、小数位、Mint 权限、Freeze 权限。
        * 类似于 Token 的“身份证”。
    2. **Token Account (ATA - Associated Token Account)**:
        * **作用**: 存储**特定用户**持有的**特定 Token** 数量。
        * **地址推导**: `ATA = Hash(User_Pubkey, Mint_Pubkey, Token_Program_ID)`。是 PDA 的一种应用。
        * **区别**: ETH 的余额记在合约的 Map 里；Solana 的余额记在用户拥有的 ATA 账户的 Data 里。
    3. **Metadata Account (元数据账户)**:
        * SPL Token 本身不存名字、Logo。
        * 需配合 **Metaplex** 标准，通过 PDA 指向一个 Metadata Account 存储 Token Name, Symbol, URI 等信息。

### 3. 实战：发行与管理 Token

#### 方法 A: 使用 Solana CLI (`spl-token`)

适用于快速测试和脚本化操作。

1. **创建 Token (Mint Account)**:

    ```bash
    spl-token create-token
    # 输出 Token Address (Mint ID)
    ```

2. **创建 ATA 账户 (来接收币)**:

    ```bash
    spl-token create-account <TOKEN_MINT_ADDRESS>
    ```

3. **铸造代币 (Mint)**:

    ```bash
    spl-token mint <TOKEN_MINT_ADDRESS> 100
    # 增发 100 枚到当前钱包的 ATA
    ```

4. **查看账户与余额**:

    ```bash
    spl-token accounts
    spl-token balance <TOKEN_MINT_ADDRESS>
    ```

*Tips: 可以通过生成特定前缀的 Keypair (靓号) 来作为 Token Mint 地址 (如 `HKD...`)。*

#### 方法 B: 使用 Web3.js 代码交互

适用于 DApp 开发。需引入 `@solana/web3.js` 和 `@solana/spl-token`。

```typescript
import { 
    createMint, 
    getOrCreateAssociatedTokenAccount, 
    mintTo, 
    transfer 
} from '@solana/spl-token';

// 1. 创建 Mint
const mint = await createMint(
    connection,
    payer,           // 付费账户
    mintAuthority,   // 铸币权限拥有者
    freezeAuthority, // 冻结权限拥有者 (可选)
    9                // 小数位
);

// 2. 获取或创建 ATA (收款人地址)
const tokenAccount = await getOrCreateAssociatedTokenAccount(
    connection,
    payer,
    mint,
    payer.publicKey
);

// 3. 铸币 (Mint To ATA)
await mintTo(
    connection,
    payer,
    mint,
    tokenAccount.address,
    authority,
    1000000000 // 数量 (需考虑 decimals)
);

// 4. 转账
await transfer(
    connection,
    payer,
    sourceTokenAccount.address,
    destTokenAccount.address,
    owner,
    amount
);
```

### 4. Token-2022 (Token Extensions)

* **背景**: 为了解决 SPL Token 功能单一（如无法原生支持转账扣税、隐私等）的问题，推出了 Token-2022 标准。
* **架构**: 无需部署新程序，直接使用 Token-2022 Program ID。
* **新特性**:
  * **Transfer Tax**: 链上原生支持交易税。
  * **Metadata 扩展**: 类似 NFT，直接将元数据写入 Token 账户扩展区，无需依赖 Metaplex 外部账户。
  * **Confidential Transfer**: 基于零知识证明的隐私转账。

---
> **Q&A 精选**:
>
> * **前端技术栈**: Solana 开发首选 **React + Next.js** (Web2/3 通吃)，配合 `solana-web3.js`。
> * **后端技术栈**: Node.js/TypeScript 生态最完善，Go 也可以做后端但写不了合约。
> * **入门建议**: 先学 Rust 合约开发，理解链上机制，再学前端交互。不懂合约很难做深入的后端数据分析或 Infra。
