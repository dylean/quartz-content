---
title: 第三次课课程笔记：互联网资本市场与链上存储实战
slug: solana-third-class
published: 2026-01-16
description: 深入探讨 Internet Capital Market 的三大支柱（稳定币、RWA、支付），并进行 Solana 链上数据存储程序（Simple Chain Storage）的实战开发。
tags:
  - Solana
  - Rust
  - SBF
  - Chain_Storage
  - RWA
category: Web3
draft: false
---

> [!TIP]
> **课程概览**
>
> * **主题**: 互联网资本市场的技术实现 & Solana 智能合约开发入门
> * **第一部分 (Mike)**: 互联网资本市场愿景 (Stablecoins, RWA, Payments)
> * **第二部分 (万彪)**: 搭建开发环境、RPC 接口、手写简单的链上数据存储程序 (Simple Chain Storage)

---

## 第一部分：互联网资本市场 (Internet Capital Market)

**主讲人**: Mike (Solana Foundation)

### 1. 行业演进与愿景

* **演进路径**:
  * **2009 Bitcoin**: 点对点支付，去中介化。
  * **2020 DeFi Summer**: 以 Uniswap 为代表的去中心化应用爆发，以太坊确立“世界计算机”地位。
  * **现在 (Next Gen Fintech)**: 行业进入“互联网资本市场”阶段。核心不再是单纯的去中心化，而是**合规**与**企业级金融**的采纳，将全球资本市场搬到统一的区块链网络上。
* **三大支柱**: **稳定币 (Stablecoins)**、**真实世界资产 (RWA)**、**支付 (Payments)**。

### 2. 稳定币 (Stablecoins)

| 特性 | 直接发行模式 (Issued Stablecoin) | 代币化存款 (Tokenized Deposits) |
| :--- | :--- | :--- |
| **代表资产** | USDT, USDC, PYUSD | 数字港元, JPM Coin |
| **背书机制** | 机构在托管金库持有等值法币/国债 | 银行 1:1 锚定法币存款 |
| **侧重点** | 广泛的流通性与 DeFi 组合 | 银行间结算，合规与安全性 |

* **Token Extensions (Token-2022)**
    Solana 推出的新标准，原生支持企业级合规需求：
  * **Permanent Delegate**: 允许发行方永久拥有控制权（冻结/销毁），这是合规稳定币的硬性要求。
  * **Transfer Hook**: 交易前/后自动触发钩子程序，可用于实时 KYC 检查。
  * **Confidential Transfer**: 隐私转账（隐藏金额），预计 2026 年大规模应用。

### 3. 真实世界资产 (RWA)

* **从 "T+2" 到 "T+0"**: 传统券商是电子化记账（依赖中介信用），RWA 是代币化确权（全球流动性，即时结算）。
* **资产分层**:
  * **Level 1**: 稳定币（最早的 RWA）。
  * **Level 2**: 国债/货币基金 (Money Market Funds)。
    * *代表*: **BlackRock**, **Franklin Templeton (Benji APP)**, **Ondo**。
  * **Level 3**: 美股代币化。
    * *代表*: **Xstock** (Superstate)。通过合规架构将美股映射到链上，实现 24/7 交易和 DeFi 组合（如股票代币作抵押借贷）。

---

## 第二部分：Solana 智能合约开发实战

**主讲人**: 万彪

### 1. 核心概念：Account 模型

在 Solana 中，一切皆账户 (`Account`)。通过 RPC 接口 `getAccountInfo` 可获取账户详情，其核心结构如下：

| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| `lamports` | `u64` | 账户余额 (1 SOL = $10^9$ lamports) |
| `data` | `Vec<u8>` | **存储的二进制数据** (程序的状态/内存) |
| `owner` | `Pubkey` | **所有者程序 ID** (只有 Owner 能修改此账户数据) |
| `executable` | `bool` | 是否为可执行程序 (智能合约本身也是账户) |
| `rent_epoch` | `u64` | 租金豁免标记 |

### 2. 核心理论：BPF 与 Entrypoint

* **运行机制**: Solana 合约编译为 **SBF (Solana Bytecode Format)**，这是 BPF 的变体，运行在沙盒环境中，极为高效。
* **程序入口**:
    Solana 程序没有 `main` 函数，而是通过 `entrypoint!` 宏定义入口。

    ```rust
    entrypoint!(process_instruction);
    
    fn process_instruction(
        program_id: &Pubkey,      // 当前程序 ID
        accounts: &[AccountInfo], // 传入的所有账户列表
        instruction_data: &[u8],  // 指令参数 (字节数组)
    ) -> ProgramResult {
        // 业务逻辑...
        Ok(())
    }
    ```

### 3. 实战项目：链上数据存储器 (Simple Chain Storage)

**需求**: 每一个用户都可以在链上拥有一个属于自己的“笔记本”（PDA 账户），可以写入数据，也可以修改数据。

#### 3.1 关键技术细节

1. **PDA (Program Derived Address)**:
    * *比喻*: 你开了一家公司（Program），公司去银行办了一张副卡（PDA）。这张卡挂在公司名下，但由你（User）通过公司流程来管理。
    * **特性**: PDA 没有私钥，只能由程序通过 `seeds` 签名 (`invoke_signed`)。
2. **租赁豁免 (Rent Exemption)**:
    * Solana 为了防止状态爆炸，要求账户存够一定量的 SOL 作为“押金”。
    * **一次性存够 2 年租金**，即可永久免费存储。
    * 计算公式: `Rent::get()?.minimum_balance(data_len)`.

#### 3.2 核心代码逻辑

**功能 1: 初始化并写入数据 (Initialize)**

```rust
// 1. 获取账户
let account_info_iter = &mut accounts.iter();
let user = next_account_info(account_info_iter)?; // 签名者，付钱的人
let pda_account = next_account_info(account_info_iter)?; // 要创建的存储账户
let system_program = next_account_info(account_info_iter)?; 

// 2. 计算 PDA 并校验
let (expected_pda, bump_seed) = Pubkey::find_program_address(
    &[b"storage", user.key.as_ref()], 
    program_id
);
assert_eq!(pda_account.key, &expected_pda);

// 3. 如果账户不存在（lamports == 0），则创建
if pda_account.lamports() == 0 {
    let space = instruction_data.len(); // 数据长度
    let rent = Rent::get()?.minimum_balance(space); // 计算租金

    // CPI 调用 System Program 创建账户
    invoke_signed(
        &system_instruction::create_account(
            user.key, 
            pda_account.key, 
            rent, 
            space as u64, 
            program_id // 将 PDA 的 owner 设为当前程序
        ),
        &[user.clone(), pda_account.clone(), system_program.clone()],
        &[&[b"storage", user.key.as_ref(), &[bump_seed]]], // 签名种子
    )?;
}

// 4. 写入数据
let mut data = pda_account.try_borrow_mut_data()?;
data[..].copy_from_slice(instruction_data);
```

**功能 2: 更新数据与内存重分配 (Update & Realloc)**

当用户更新数据时，新数据的长度可能变长或变短。

```rust
let new_len = new_data.len();

// 1. 调整账户大小 (Realloc)
pda_account.realloc(new_len, false)?;

// 2. 租金调节 (Rent Adjustment)
let required_lamports = Rent::get()?.minimum_balance(new_len);
let current_lamports = pda_account.lamports();

if current_lamports < required_lamports {
    // 扩容：钱不够，让 User 补钱 (Transfer)
    let diff = required_lamports - current_lamports;
    invoke(
        &system_instruction::transfer(user.key, pda_account.key, diff),
        &[user.clone(), pda_account.clone(), system_program.clone()],
    )?;
} else {
    // 缩容：钱多了，退还给 User
    let diff = current_lamports - required_lamports;
    // 直接修改 lamports (因为程序是 PDA 的 owner，可以直接扣款)
    **pda_account.try_borrow_mut_lamports()? -= diff;
    **user.try_borrow_mut_lamports()? += diff;
}

// 3. 写入新数据
pda_account.try_borrow_mut_data()?.copy_from_slice(new_data);
```

### 4. Q&A 重点

> [!NOTE]
> **Q: 为什么官方 RPC 经常报 CORS 错误？**
>
> * 这通常是浏览器的安全策略。建议本地开发使用 `vite` 的 proxy 功能转发请求，或者使用支持 CORS 的第三方 RPC 服务（如 Helius, QuickNode）。

> [!NOTE]
> **Q: Solana Program Library (SPL) vs Anchor?**
>
> * **Native (solana-program)**: 偏底层，手动处理字节序列化，适合学习原理。推荐新手先写原生代码。
> * **Anchor**: 这里的“React 框架”。封装了账号校验、序列化 (Borsh)、CPI 等细节。生产环境强烈推荐使用 Anchor。

> [!NOTE]
> **Q: Pinocchio 是什么？**
>
> * 一个新的轻量级 Solana 库。相比官方库，它去除了很多冗余依赖，能显著减少编译后的 `.so` 文件大小（从而节省部署时的 SOL 费用）并提高运行效率。
