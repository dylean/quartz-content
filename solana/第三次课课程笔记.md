---
title: 第四次课课程笔记：互联网资本市场与代币开发实战
slug: solana-fourth-class
published: 2026-01-16
description: 深入探讨 Solana 作为互联网资本市场的愿景，以及从零构建泰铢币（Thai Zhu Coin）合约的实战开发笔记。
tags:
  - Solana
  - Rust
  - DeFi
  - RWA
category: Web3
draft: false
---

> [!TIP]
> **课程概览**
>
> * **主题**: 互联网资本市场的技术实现 & Solana 智能合约开发入门
> * **第一部分 (Mike)**: 互联网资本市场愿景 (Stablecoins, RWA, Payments)
> * **第二部分 (万彪)**: 搭建开发环境、RPC 接口、手写简单的链上数据存储程序 (Simple Chain Storage)

---

## 第一部分：互联网资本市场 (Internet Capital Market)

**主讲人**: Mike (Solana Foundation)

### 1. 行业演进与愿景

* **演进路径**:
  * **2009 Bitcoin**: 点对点支付，去中介化。
  * **2020 DeFi Summer**: 以 Uniswap 为代表的去中心化应用爆发，以太坊成为世界计算机。
  * **现在 (Next Gen Fintech)**: 行业进入新阶段，强调**合规**与**企业级金融**采纳。从单纯的“去中心化创新”转向“互联网资本市场”。
* **互联网资本市场 (Internet Capital Market)**:
  * 核心愿景是将全球资本市场搬到统一的网络载体（互联网/区块链）上，共享统一的流动性层。
  * 三大支柱：**稳定币 (Stablecoins)**、**真实世界资产 (RWA)**、**支付 (Payments)**。

### 2. 稳定币 (Stablecoins)

* **解决痛点**: 跨境支付慢（1-3天）、中间环节多（电汇/中介）、成本高。
* **技术形态**:
  * **直接发行模式 (Issued Stablecoin)**: 如 USDT, PYUSD。机构接收法币存入托管金库 (Reserve)，在链上发行 1:1 或超额抵押的 Token。
  * **代币化存款 (Tokenized Deposits)**: 银行探索的方向（如香港、数字人民币）。相比稳定币更强调 1:1 锚定法币存款，而不是国债储备。
* **合规发行流程**:
  * **Reserve**: 银行或托管机构持有法币/美债。
  * **Tokenization Engine**: 将存款映射为链上 SPL Token。
  * **Wallet**: 托管钱包或用户自托管。
  * **Compliance**: 需集成 KYC (Know Your Customer) / AML (反洗钱) / KYT (Know Your Transaction)。
* **Token Extensions (Token-2022)**:
  * Solana 推出的新代币标准，原生支持企业级合规需求：
    * **Permanent Delegate**: 允许发行方永久拥有控制权，实现冻结 (Freeze)、没收 (Seize/Burn)、强制转账。
    * **Transfer Hook**: 交易发生时自动触发链上程序钩子，可用于实施即时合规检查（如白名单验证）。
    * **Confidential Transfer**: 隐私转账（发送方、接收方、金额加密），预计 2026 年成为重点。
    * **Interest Bearing**: 自动计息功能，适合生息资产。

### 3. 真实世界资产 (RWA)

* **从纸质记帐到链上流动性**: 券商是电子化记账（T+1/T+2，依赖中介信用），RWA 是代币化确权（T+0 结算，非托管，全球流动性）。
* **资产分层**:
  * 稳定币是最早的 RWA。
  * 美国国债/货币基金 (Money Market Funds)：如 **BlackRock**, **Franklin Templeton (Benji)**, **Ondo**。
  * 美股代币化：**Xstock** (Superstate)，通过合规架构将美股映射到 Solana 链上，实现 24/7 交易、碎片化购买、且可作为 DeFi 抵押品。
* **Project Open**: Solana Policy Institute 与 SEC 探讨的合规监管框架，旨在利用区块链的可编程性（如 Token Extensions）实现自动化的监管合规。

### 4. 支付 (Payments)

* **Solana Pay**: 开源免费的支付框架，类似去中心化的支付宝/微信支付。
  * **Transaction Request**: 比如星巴克积分、动态折扣、NFT会员卡。
  * **Transfer Request**: 简单的扫码转账。
* **Blinks**: 将 Solana Pay链接转化为 URL/二维码，任何支持 Blink 的前端（如推特、钱包）都能直接渲染出支付界面。
* **Gasless Transactions**: 通过 **Gas Station** 或 **Relayer** (如 Coral 用于 OKX 钱包) 代付 Gas，用户体验无感化。

---

## 第二部分：Solana 智能合约开发实战

**主讲人**: 万彪

### 1. 开发环境搭建

* **安装**: 使用官方一键安装脚本 (Solana Tool Suite)，包含 `solana-cli`, `rust`, `anchor-cli` 等。
* **本地节点**: 使用 `solana-test-validator` 启动本地测试链（默认端口 8899）。
  * 这是开发必备，提供了本地的 RPC 和水龙头。
* **RPC 交互**:
  * `getAccountInfo`: 获取账户详情。账户结构包含 5 个关键字段：
    * `lamports`: 余额 (1 SOL = 10^9 lamports)。
    * `data`: 存储的二进制数据。
    * `owner`: 账户的所有者程序 ID。
    * `executable`: 是否为可执行程序。
    * `rent_epoch`: 租金相关（也就是 Rent Exemption）。
  * `getBalance`, `getTransaction`, `sendTransaction`。

### 2. 核心概念：BPF 与 Rust

* **为什么用 Rust?**: Solana 智能合约编译为 **BPF (Berkeley Packet Filter)** 字节码（现称为 **SBF - Solana Bytecode Format**）。
  * BPF 最初用于 Unix 内核网络包过滤，因其高性能和沙盒安全性演变为通用虚拟机。
  * Rust 是目前编写 BPF 程序最成熟的语言。
* **程序入口**: 不同于常规 Rust 程序，Solana 合约没有 `main` 函数，而是定义 `entrypoint!`:

    ```rust
    entrypoint!(process_instruction);
    fn process_instruction(
        program_id: &Pubkey,
        accounts: &[AccountInfo],
        instruction_data: &[u8],
    ) -> ProgramResult
    ```

### 3. 实战项目：链上数据存储器 (Simple Chain Storage)

* **需求**: 用户希望在链上存储一段任意数据（如文本、配置、游戏存盘），数据归用户所有，可更新，且按需付费。

#### 3.1 关键技术细节

1. **租赁豁免 (Rent Exemption)**:
    * Solana 链上存储数据需要支付租金。为避免定期扣费导致的状态不确定性，Solana 采用“一次性存够 2 年租金即永久豁免”的机制。
    * **计算**: `Rent::get()?.minimum_balance(data_len)`。
2. **PDA (Program Derived Address)**: "程序派生地址"。
    * **比喻**: 就像你开了一家公司（Program），公司去银行办了一张卡（PDA）。这张卡的所有者是公司，而不是你个人，但你通过控制公司来管理这张卡。
    * **特性**: PDA 没有私钥，无法直接签名。需要通过 `invoke_signed` 由程序使用 `Seeds` 动态“签署”。
3. **Instruction Data (指令数据)**:
    * Solana 交易是基于账户的。指令执行必须显式传入所有涉及的账户 (`accounts`) 和指令参数 (`data`)。

#### 3.2 代码逻辑实现

* **Cargo.toml**: 配置 `crate-type = ["cdylib", "lib"]`。`cdylib` 用于编译成 `.so` 部署，`lib` 用于本地测试。
* **功能 1: 初始化数据账户 (Initialize)**
  * **步骤**:
        1. 从 `instruction_data` 获取用户想要存储的数据。
        2. 计算 PDA 地址 (`find_program_address`)。
        3. 判断 PDA 是否存在（通过检查 `lamports` 是否为 0）。
        4. 计算所需租金 (`Rent::minimum_balance`)。
        5. 构建 `system_instruction::create_account` 指令。
        6. **关键**: 使用 `invoke_signed` 调用系统程序创建账户。因为 PDA 没有私钥，必须由程序提供 Seeds 来完成 CPI (Cross-Program Invocation) 签名。
        7. 将数据写入 PDA 的 `data` 字段。
* **功能 2: 更新数据 (Update)**
  * **Realloc**: 使用 `account.realloc(new_len, false)` 调整账户数据空间大小。
  * **租金调节 (Rent Adjustment)**:
    * **数据变长 (扩容)**: 需要补交租金。从用户钱包 `transfer` SOL 到 PDA 账户。
    * **数据变短 (缩容)**: 退还多余租金。从 PDA 账户直接扣除 lamports 加回到用户钱包（程序拥有 PDA，可直接修改其 lamports，无需 `transfer` 指令签名，只需遵守总额不变原则）。

#### 3.3 部署与交互

* **部署**: `cargo build-sbf` 生成 `.so` 文件，使用 `solana program deploy` 部署。
  * **UDP 限制**: 部署时因为文件大，CLI 会将其拆分为几百个交易发送。
  * **交易大小限制**: 单个 Solana 交易最大 **1232 字节**（受限于网络 MTU 1280 字节 - 48 字节 Headers）。因此指令数据和账户数量即使很多，也不能超过此限制。
* **交互**: 构造 Transaction，传入 `program_id` 和 `accounts = [User, PDA, SystemProgram, RentSysvar]`。
* **可升级性 (Upgradability)**:
  * 当前默认使用 **BPF Loader v3**。
  * 部署后实际产生两个账户：
        1. **Program Account**: 代表程序 ID，是一个“指针”。
        2. **Program Data Account**: 存储实际编译后的字节码。
  * 升级时，只需部署新代码到新的 Data Account，并将 Program Account 指向它即可。

### 4. Q&A 重点

* **跨域问题 (CORS)**: 官方 RPC 可能会屏蔽浏览器直接请求。解决方案：使用反向代理（如 Vite 的 proxy 配置）或使用允许 CORS 的商业 RPC（如 Helius/QuickNode）。
* **Build 失败**: 常见的版本依赖冲突。建议在 `Cargo.toml` 锁定版本，或使用讲师提供的预构建环境。
* **PDA 派生**: PDA 只能由其Owner程序派生（Seed 机制）。"别人的 PDA" 无法通过你的程序签名，除非逻辑允许。
* **Solana Program vs Anchor**:
  * `solana-program`: 原生库，偏底层，适合理解原理，但繁通过琐。
  * `Anchor`: 框架，封装了序列化、鉴权等细节，类似 React 之于原生 DOM。推荐生产环境使用 Anchor，但学习阶段建议先手写原生代码理解 Account 模型。
* **Pinocchio**: 新兴的高性能 Solana 库，旨在替代臃肿的 `solana-program`，部署体积更小、Gas 更低。

---
> **相关资源**:
>
> * 示例代码库: `lab-pixel-ss` (Simple Storage)
> * 工具链: `cargo-build-sbf`, `solana-test-validator`
> * RPC: `getAccountInfo`, `sendTransaction`
